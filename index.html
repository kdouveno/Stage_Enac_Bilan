<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rapport de Stage - ORB_SLAM2</title>
    <link rel="stylesheet" href="main.css">
</head>
<body class="dark_theme">
	<div id="top-bar">
		<svg id="dark-button" height="50px" width="100px" onclick="switchBlackTheme(this)" viewBox="0 0 400 200">
			<defs>
				<path id="frame_template"/>
				<clipPath id="frame_path">
					<use href="#frame_template"/>
				</clipPath>
				
				<path class="inner" id="star_template" d="M 0 60 A 60 60 0 0 1 60 0 A 60 60 0 0 1 0 -60 A 60 60 0 0 1 -60 0 A 60 60 0 0 1 0 60"/>
				<path class="inner" id="moon_template" d="M 0 -60 A 60 60 0 1 1 -60 0 A 50 50 0 1 0 0 -60 Z"/>
				<path id="rect_path" d="M -200 -100 H 200 V 100 H -200 Z"/>
				<path class="inner" id="hole_template" d="m 0 -85 a 1 1 0 0 0 0 170 a 1 1 0 0 0 0 -170 z"/>

				
			</defs>
			<g id="svg_container">
					<g clip-path="url(#frame_path)" >
						<defs>
							<use id="moon" href="#moon_template" x=100 />
							<use id="star" href="#star_template" x=-100 />
							
							<clipPath id="hole_clip">
								<use id="hole" href="#hole_template"/>
							</clipPath>
						</defs>
						<g clip-path="url(#hole_clip)">
							<use href="#moon" class="icon" />
							<use href="#star" class="icon" />
						</g>
						<mask id="frame_mask" style="fill: black">
							<use href="#rect_path" style="fill: white" />
		
							<use href="#hole_template" />
							<use href="#moon" style="fill: black"/>
							<use href="#star" style="fill: black"/>
						</mask>
					</g>
					<use id="frame" href="#frame_template" mask="url(#frame_mask)" />
					<use href="#frame_template" fill="transparent"/>

				</g>
			</svg>
		<script>
				function switchBlackTheme() {
					var e = document.body;
					if(e.getAttribute("class") === "dark_theme") e.setAttribute("class", "");
					else e.setAttribute("class", "dark_theme");
				}
			</script>
	</div>
	<div id="container">
        <div id="Cover">
            <h1>ORB_SLAM2</h1>
            <h2>by Raul Mur-Artal</h2>
            <p>Internship report</p>
        </div>
        <div id="summary">
            <div></div>
        </div>
        <div id="introduction">
			<h3>Introduction</h3>
			<div>
				<p>ORB-SLAM2 is a real-time SLAM(Simultaneous Localization And Mapping) library for Monocular, Stereo and RGB-D cameras that computes the camera trajectory and a sparse 3D reconstruction (in the stereo and RGB-D case with true scale).
					It is able to detect loops and relocalize the camera in real time.
					It provides several executables for different camera types as well as for ROS support.
					It use <a>OpenCv</a> for matrix manipulation and its <a>ORB</a> algorythm for feature extraction, Pangolin for graphic interface and</p>
				<p>ENAC searchers have been intrested in that technology (SLAM Algorythm) but had trouble with running Raul's programm in real time. I was hired as a c++ assistant to bring more comprehension and code knowledge and eventually optimize the programm. Indeed the programm is runnning quite not effictively.</p>
				<p>During my intershihp I mainly focused on the executable of ORB_SLAM2 librairy that provided real-time handling : the Monocular ROS version. It is the most Intresting part of the programm. I used different lenses on an uEye camera by IDS to test the programm.</p>
				<div>
					<h3>What is Simultaneous Localization And Mapping, SLAM</h3>
					<p>SLAM is a technique that is used to locate a camera in its environment and create a map of this environment. Some SLAM algorythm like ORB_SLAM2 can even handle SLAM with monocular camera. What that means is the programm can build a 3D map and locate a camera in it only analysing the video output of that camera.</p>
				</div>
				<div>
					<h3></h3>
				</div>
			</div>
		</div>
		<div id="running">
			<h3>Running the programm</h3>
			<div>
				<div id="installation">
					<h3>Installation</h3>
					<div>
						<p>To be able run ORB_SLAM2 with ROS on Ubuntu v.16+, make sure you have apt-get utility tool (built in Ubuntu). Because you'll have to install the following packages</p>
						<h4>with apt</h4>
						<ul>
							<li>git</li>
							<li>gcc / clang</li>
							<li>libgl1-mesa-dev (package name for opengl librairy)</li>
							<li>libeigen3 (Eigen 3)</li>
							<li>Ros</li>
						</ul>
						<h4>with git</h4>
						<ul>
							<li>OpenCv</li>
							<li>Pangolin</li>
							<li>ORB_SLAM2</li>
						</ul>
					</div>
				</div>
				<div>
					<h3>Monocular camera calibration</h3>
					<div>
						<p>In order to use my uEye camera. I had to ~~install both the IDS's uEye linux driver and the ros-kinetic-ueye-cam driver-node package via apt. Once it's done I could launch the uEye </p>
					</div>
				</div>
				<div>
					<h3>Launch ORB-SLAM2</h3>
				</div>
				<div>
					<h3>First observations</h3>
					<div>
						
					</div>
				</div>
			</div>
		</div>
		<div id="directions">
			<h3>Possible search directions</h3>
			<div>
				<p>ENAC's earchers have emmited several hypotheses about why the programm is running that bad. They wondered if the code was robust enough, and so did the hardware. They also pointed at the camera properties (resolution, Field of view, calibration), and possible bad habits in ROS use.</p>
				<div id="raul">
					<h3>Raul Mur-Artal on ORB_SLAM2</h3>
					<div>
						<p>Raul is a searcher scientist, he made ORB_SLAM as part of his thesis. As an ex PhD student, he has acquired certain skills, in algorythm and c++ developpement. So the chances for the code to be unefficient or not optimized is rather too low or unsolvable for me. <p>
						<p>ORB_SLAM2 is a sequel to ORB_SLAM, this version adds RGB-D camera and sterero support. But the main purpose of ORB_SLAM is to have a SLAM algorithm that works with the cheapest capture set-up possible: a single camera.</p>
					</div>
				</div>
				<div id="code">
					<h3>The Code</h3>
					<svg width="100%" viewBox="0 0 1800 900">
						<rect x="0" y="0" width="100%" height="100%"/>
						<g>
							<defs>
								<g id="camera">
									<path id="case" d="M 75 50 h -150 v -100 h 150 z"/>
									<path id="lens" d="M 75 0 l 50 50 v -100 z"/>
									<path id="wheel"
										d="	M 0 -40 a 1 1 0 0 0 0 80 a 1 1 0 0 0 0 -80 z
											M 0 -30 a 1 1 0 0 0 0 20 a 1 1 0 0 0 0 -20 z
											M 0 10 a 1 1 0 0 0 0 20 a 1 1 0 0 0 0 -20 z
											M 20 -10 a 1 1 0 0 0 0 20 a 1 1 0 0 0 0 -20 z
											M -20 -10 a 1 1 0 0 0 0 20 a 1 1 0 0 0 0 -20 z
											"/>
								</g>
								<g id="mountain">
									<path id="pic" d="M 0 -10 l 30 60 h -60 z"/>
									<path id="edge" d="M 0 -10 l 10 20 h -20 z"/>
								</g>

								<path id="borders" d="M 75 50 h -150 v -100 h 130 l 20 20 z"/>

								<g id="picture">
									<use id="background" href="#borders"/>
									<use class="inner_picture" href="#mountain" style="transform: translate(-50px, 7px) scale(.8)"/>
									<use class="inner_picture" href="#mountain" style="transform: translate(40px, 17px) scale(.6)"/>
									<use class="inner_picture" href="#mountain" style="transform: translate(0px, -15px) scale(1.2)"/>
									<path class="inner_picture" id="picture_star" d="M 0 60 A 60 60 0 0 1 60 0 A 60 60 0 0 1 0 -60 A 60 60 0 0 1 -60 0 A 60 60 0 0 1 0 60" style="transform: translate(-40px, -20px) scale(.5)"/>
									<use href="#borders" />
								</g>
								<g id="keyframe">
									<use href="#picture"/>
									<path id="key" d="M -5 15 a 20 20 0 1 1 -10 -10 l 40 -40 l 20 20 l -10 10 l -10 -10 l -5 5 l 10 10 l -10 10 l -10 -10 z"/>
								</g>
								<path id="arrow" d="M -10 -20 l 20 20 l -20 20"/>
							</defs>
							<line class="dasharray_line" x1="0" y1="300"
								  x2="1800" y2="300"/>
							<line class="dasharray_line" x1="300" y1="600"
								  x2="1800" y2="600"/>
							<line class="dasharray_line" x1="300" y1="0"
								  x2="300" y2="900"/>
							<line class="dasharray_line" x1="900" y1="0"
								  x2="900" y2="300"/>
							<use href="#camera" x=120 y=150 />
							<use href="#arrow" x=300 y=150 />

							<g style="transform:translate(470px, 130px)" opacity=".33" >
								<use href="#picture"/>
								<use href="#arrow" style="transform: translate(150px, -5px)"/>
							</g>
							<g style="transform:translate(450px, 150px)" opacity=".66">
								<use href="#picture"/>
								<use href="#arrow" style="transform: translate(150px, 0px)"/>
							</g>
							<g style="transform:translate(430px, 170px)" >
								<use href="#picture"/>
								<use href="#arrow" style="transform: translate(150px, 5px)"/>
							</g>
							<text id="extraction_threads" style="transform: translate(450px, 270px)">1 thread/frame</text>



							<g style="transform: translate(650px, 50px)" >
								<rect width="200" height="200" />

								<text style="transform: translate(100px, 100px)">
									<tspan x=0 >ORB</tspan>
									<tspan dy="1.2em" x=0 >Extraction</tspan>
								</text>
							</g>
							<use href="#arrow" x=900 y=150 />

							<text id="tracking_thread" style="transform: translate(945px, 30px)">Tracking: 1 Thread</text>

							<g style="transform: translate(950px, 50px)" >
								<rect width="200" height="200" />

								<text style="transform: translate(100px, 100px)">
									<tspan x=0 >Initialization /</tspan>
									<tspan dy="1.2em" x=0 >Relocalization</tspan>
								</text>
							</g>
							<use href="#arrow" x=1200 y=150 />
							<g style="transform: translate(1250px, 50px)" >
								<rect width="200" height="200" />

								<text style="transform: translate(100px, 100px)">
									<tspan x=0 >Track</tspan>
									<tspan dy="1.2em" x=0 >Local Map</tspan>
								</text>
							</g>
							<use href="#arrow" x=1500 y=150 />

							<g style="transform: translate(1550px, 50px)" >
								<rect width="200" height="200" />

								<text style="transform: translate(100px, 100px)">
									<tspan x=0 >New KeyFrame</tspan>
									<tspan dy="1.2em" x=0 >Decision</tspan>
								</text>
							</g>
							
							<use href="#arrow" style="transform: translate(1650px, 300px) rotate(90deg)" />
							<use href="#keyframe" style="transform: translate(1670px, 430px); opacity: 0.33"/>
							<use href="#keyframe" style="transform: translate(1650px, 450px); opacity: 0.66"/>
							<use href="#keyframe" style="transform: translate(1630px, 470px)"/>

							<use href="#arrow" style="transform: translate(1500px, 450px) rotate(180deg)"/>


							<g style="transform: translate(1250px, 350px)" >
								<rect width="200" height="200" />

								<text style="transform: translate(100px, 82px)">
									<tspan x=0 >KeyFrame</tspan>
									<tspan dy="1.2em" x=0 >Insertion</tspan>
									<tspan dy="1.2em" x=0 >In Map</tspan>
								</text>
							</g>
							<use href="#arrow" style="transform: translate(1200px, 450px) rotate(180deg)"/>

							<g style="transform: translate(950px, 350px)" >
								<rect width="200" height="200" />

								<text style="transform: translate(100px, 100px)">
									<tspan x=0 >Local Map</tspan>
									<tspan dy="1.2em" x=0 >Adjustment</tspan>
								</text>
							</g>
							<use href="#arrow" style="transform: translate(900px, 450px) rotate(180deg)"/>
							<g style="transform: translate(650px, 350px)" >
								<rect width="200" height="200" />

								<text style="transform: translate(100px, 100px)">
									<tspan x=0 >Local Map</tspan>
									<tspan dy="1.2em" x=0 >Adjustment</tspan>
								</text>
							</g>
							<use href="#arrow" style="transform: translate(600px, 450px) rotate(180deg)"/>
	
						</g>
					</svg>
					<div>
						<p>The code looks pretty clear to me. It is well commented, each section is sapareated without impacting runtime, it is optimized, at least it looks pretty much like so to me. In any case, I don't have the means to anhance it.</p>
						<br/>
						<p>The code, and so, the programm, while in ros-monocular is divided in three main threads plus a thread per image.</p>
						<p>Each image is sent to the ORB_extractor, a feature extractor that use a Vocabulary in the form of a bag of word. I will then extract key points from each frame. Each extraction, each frame, is computed asynchonously, that means multiple images are computed at the same time.</p>
						<p>After that, each frame and it's extracted KeyPoints are sent to the tracking thread</p>
						<div id="tracking">
							<h3>Tracking</h3>
							<div>
								<p>Tracking is itself divided in 5 states</p>
								<ul>
									<li>System not ready</li>
									<li>No image yet</li>
									<li>Not initialized - To start the SLAM, ORB_SLAM2 needs an initial map, and in monocular it can't be created at first frame because monocular camera doesn't allow depths resolution, ORB_SLAM2 have to make a first look-arround to create the initial map. So this mode appears only in monocular mode</li>
									<li>OK - The system works correctly, all algorythmes are working correctly</li>
									<li>LOST - The system lost track of the map. Orb Extraction's KeyPoints doesn't match any of the MapPoints, you need to move the vamera back to somwhere registered to the map.</li>
								</ul>
								<p>Tracking decides whether or not a frame object will become a keyFrame and be registered in the KeyFrameDatabase object. It tests if there is a good balance between matching KeyPoints with MapPoint and non-matching KeyPoints.</p>
								<p>It then sends the frame to the localMapping and LoopClosing loops that are initialized at System class instantiation...</p>
							</div>
						</div>
						<div id="local_mapping">
							<h3>Local Mapping</h3>
							<div>
								<p>Local Mapping is executed asynchonously to the tracking thread and has the mission to join new KeyFrames, that are briantly stored in memory in a sort of entrance queue via mutex objects, and their KeyPoints, to the map. It does adjustment and fusion between identical neighboor KeyFrame KeyPoints.</p>
							</div>
						</div>
						<div id="loop_closing">
							<h3>Loop Closing</h3>
							<div>
								<p>Loop Closing is called whether new Keyframes are a loop candidate by checking covisibility consistency. It is also running asynchronously. If a new KeyFrame has enough KeyPoints that are not in its direct KeyFrame neighborhood, ORB_SLAM2 proceed to a loop closure. It adjust all keyframes between the keyframe covisible to the new keyframe and the new KeyFrame</p>
							</div>
						</div>
					</div>
				</div>
				<div id="camera">
					<h3>The input camera</h3>
					<div>
						<p>The camera seems to have a great impact on how effective the program is.</p>
					</div>
				</div>
			</div>
		</div>
    </div>